# 아이템_06_불필요한 객체 생성을 피하라


# **🟦 1. 서론 (Introduction)**

**발표 목적**

- **“객체 생성 자체가 문제인 게 아니라, 불필요하게 중복 생성하는 습관이 문제다.”**

**배경 / 문제 인식**

- 객체 지향 언어인 Java에서는 객체 생성을 통해 모든 것이 이루어진다.
하지만 모든 객체 생성이 의미 있는 것은 아니다. 
같은 기능을 수행하면서도 재사용 가능한 객체를 매번 새로 만드는 코드는 성능 저하와 불필요한 메모리 사용을 초래한다.

**목표 / 기대 효과**

- 불필요한 객체 생성을 하지 않고 재사용함으로서 프로그램의 성능과 코드 가독성을 높일 수 있다.

# **🟨 2. 본론 (Main Content)**

---

## **1️⃣ 핵심 개념 정리 (장점 & 단점)**

### **🔹 1️⃣ Java의 “객체 생성 = 비용이 따른다”**

- new 연산자는 단순한 메모리 할당이 아니라,
    - 클래스 로딩, 초기화, 생성자 호출, GC 대상 관리까지 포함된 **비용 있는 작업**이다.
- 가벼운 객체라면 문제 없지만,
    - 내부적으로 **복잡한 구조를 가진 객체 (예: Pattern, Connection, Thread 등)** 을 반복적으로 생성하면 큰 오버헤드가 발생한다.

### **new 연산자 vs String 불변객체**

- 불변 클래스에서 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 막을 수 있다.
    - 생성자는 호출할 때마다 새로운 객체를 생성.
    - 팩터리 메서드는 불변 객체 뿐만 아니라 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용 가능.
    - **가 반복적으로 필요한 경우 캐싱해서 재사용할 것.**

---

## **2️⃣ “보이지 않는 낭비”가 발생하는 대표 사례**

## 사례 1. **정규표현식의 Pattern 객체**

- 문자열이 로마 숫자 형태인지 검사하는 정규표현식

```jsx
static boolean isRomanNumeral(String s){
  String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
  return s.matches(regex);
}
```

### **⚠️ 발생 문제**

- 성능 저하 : 정규식을 매번 새로 해석하고 컴파일 함.
- 불필요한 객체 생성 : Pattern과 Matcher 인스턴스를 계속 새로 만듦.
    - 성능이 중요한 상황에서 반복해서 사용하기란 적합하지 않음.
    - 메서드가 내부에서 만드는 정규표현식 Pattern 인스턴스는 한번 쓰고 버려져 GC 대상이 됨.
    - Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신(Finite State Machine)을 만들기 때문에 인스턴스 생성 비용이 높음.

---

### **🔹 s.matches(regex) 내부 동작**

```jsx
String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
Pattern p = Pattern.compile(regex);
Matcher m = p.matcher(s);
return m.matches();
```

- isRomanNumeral 호출 시마다 Pattern과 Matcher 객체가 새로 생성됨.

**Pattern 객체**

- java.util.regex.Pattern 클래스의 인스턴스.
- 문자열 형태의 정규식을 JVM이 이해할 수 있는 형태로 바꿔서 저장해둔 객체.

**Matcher 객체**

- 문자열이 정규표현식 패턴과 일치하는지를 실제로 검사하는 실행기(executor).

---

### **🔷 인스턴스 생성 비용이 높음**

- Pattern.compile(regex) :
    - 정규식을 유한 상태 머신(FSM)으로 바꾸는 것은 단순 문자열 파싱이 아님.
    - 복잡한 분기/루프 구조(NFA)를 한 번 만들어 놓음 → 비용이 큼(파싱 + 상태구조 생성).

```jsx
패턴해석 -> 문자열 전이 경로 계산 -> 루프(*, +), 조건(|), 그룹(()) 처리
```

- 정규식을 Pattern.compile()로 새로 컴파일하여 Pattern 객체 생성 (NFA 구조).
    - Pattern.compile(regex)시 생성되는 Pattern 객체 생성 예시 (NFA 구조)
        
        ```jsx
        [START] --(?=.)--> [S0]
        [S0] --M--> [S0]        (M*)  (S0은 M 루프 상태)
        [S0] --ε--> [H_START]   (hundreds 분기 시작)
        
        # hundreds 분기 A (CM/CD)
        [H_START] --'C'--> [H_A1] --'M' or 'D'--> [H_A_END]
        
        # hundreds 분기 B (D? C{0,3})
        [H_START] --ε--> [H_B0]
        [H_B0] --'D'--> [H_B1]   (optional D)
        [H_B0] --ε--> [H_B1]
        [H_B1] --'C'--> [H_B2] --'C'--> [H_B3] --'C'--> [H_B4]
        (각 H_B* 상태는 C{0,3} 반복)
        
        # after hundreds
        [H_A_END] --ε--> [T_START]
        [H_B4]     --ε--> [T_START]
        
        # tens 분기 (유사)
        [T_START] --'X'--> ... (X[CL] branch)
        or
        [T_START] --ε--> ... (L? X{0,3} branch)
        
        # ones 분기 (유사)
        ... --> [ONES_START]
        [ONES_START] --'I' ... or --ε--> ... (V? I{0,3})
        
        # 끝
        [...] --> [ACCEPT] --(must be at end due to $)-->
        ```
        
- Matcher 객체를 생성 후 m.matches() 수행 → 매칭 결과 반환.
- 결과 반환 후 Pattern, Matcher 모두 GC 대상.

---

## **3️⃣ 문제점 & 해결 방안**

### **성능 개선 방법**

- 필요한 정규식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성하여 캐싱.
- 나중에 isRomanNumeral 메서드가 호출될 때마다 해당 인스턴스를 재사용.

```jsx
public class RomanNumerals {
  private static final Pattern ROMAN = Pattern.compile(
    "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

  static boolean isRomanNumeral(String s) {
    return ROMAN.matcher(s).matches();
  }
}
```

### **개선 효과**

- 성능 개선 : 6.5배 정도 빨라짐 (길이가 8인 문자열 기준).
- 코드의 의미가 잘 드러남 : Pattern 인스턴스를 static final 필드로 끄집어내 의미를 명확히 함.

---

### **🔶 정적 유틸리티 메서드 vs 정적 팩터리 메서드**

| **구분** | **정적 유틸리티 메서드 (Static Utility)** | **정적 팩토리 메서드 (Static Factory)** |
| --- | --- | --- |
| 목적 | 특정 기능 수행, 계산, 검사 등 | 객체 생성 및 반환 |
| 반환 값 | 주로 primitive, boolean, void 등 | 항상 객체 인스턴스 |
| 객체 생성 | 기존 객체를 재사용할 수 있음, 새 객체 생성 필수 아님 | 새로운 객체 생성하거나, 캐시된 인스턴스 반환 가능 |
| 예시 | Math.max(a,b), Collections.sort(list), RomanNumerals.isRomanNumeral(s) | Integer.valueOf(42), LocalDate.of(2025,10,24) |

## **사례 1. 어댑터(Adapter) 객체**

- 어댑터는 뒷단 객체에 요청을 위임하는 뷰(View) 역할을 함.
- 어댑터 자체는 불변처럼 보이지만, 내부적으로 상태나 캐시를 가질 수 있음.
- 뒷단 객체가 변경되면 어댑터를 재사용할 때 “**상태 공유 문제”**가 생길 수 있음.
- ✅ 결론: 겉보기 불변이라도 재사용 시 주의가 필요.

## **사례 2. Map 인터페이스의 keySet 메서드**

```jsx
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

Set<String> keys1 = map.keySet();
Set<String> keys2 = map.keySet();
```

| **개념** | **설명** |
| --- | --- |
| keySet() | Map의 키 전체를 보여주는 “뷰(View)” 객체 반환 |
| 뷰(View) | 원본 Map을 감싸서 간접적으로 접근하게 하는 객체 |
| 공유 구조 | map을 수정하면 keySet() 결과도 즉시 반영됨 |
| 특징 | 복사본이 아닌, 원본과 실시간 연결된 객체 |
- keySet()은 새로운 Set 복사본을 만들지 않음.
- 내부적으로 같은 Set 뷰를 반환하거나 동일한 기능의 뷰를 만들어도 결과 동일.
- 불필요한 객체 생성을 방지할 수 있음.

---

## **사례 3. 오토박싱 (auto boxing)**

```jsx
private static long sum() {
    Long sum = 0L; // ❌ Long (박싱 타입)
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

### ⚠️ **문제점**

- sum이 박싱 타입(Long)이므로 sum += i; 연산 시마다 새로운 Long 객체가 생성됨.
- 반복문이 21억 번 도는 동안 21억 개의 Long 객체가 만들어짐.

✅ **개선 코드**

```jsx
private static long sum() {
    long sum = 0L; // ✅ 기본 타입 사용
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

| **코드** | **실행 시간(대략)** |
| --- | --- |
| Long sum = 0L | 6.3초 |
| long sum = 0L | 0.59초 |

---

### **객체 생성은 비싸니 항상 피해야 한다? → ❌**

- 현대 JVM에서는 단순한 객체 생성/회수는 부담이 크지 않음.
- 명확성, 간결성, 기능 향상을 위해 객체를 추가 생성하는 것은 오히려 바람직함.

---

### **객체 풀(pool) 사용에 대한 주의점**

- DB 연결처럼 생성 비용이 큰 객체는 재사용 추천.
- 하지만 일반 객체는 직접 풀을 만들지 말 것.
- 자체 풀은 코드 복잡도 증가, 메모리 낭비, 성능 저하를 유발.
- JVM의 GC가 경량 객체 처리에 훨씬 효율적임.

---

### **🔶 아이템 6 vs 아이템 50 (방어적 복사)**

| **구분** | **아이템 6** | **아이템 50** |
| --- | --- | --- |
| 내용 | 기존 객체를 재사용해야 한다면 새 객체를 만들지 말라 | 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라 |
| 피해 규모 | 성능 저하 정도 | 🚨 버그 및 보안 구멍 위험 |
| 요약 | 불필요한 객체 생성을 피하라 | 방어적 복사를 게을리하지 말라 |

# **🟩 3. 요약 (Summary / Conclusion)**

**핵심 포인트 요약**

- 객체 생성은 비용이 클 경우, **재사용 가능한 객체는 재사용**하라. (항상 객체 생성 비용이 비싼 것은 아님)
- 정규식 Pattern, 불변 객체, 뷰(View) 객체 등은 캐싱하여 재사용하면 성능 향상.
- 오토박싱과 같은 **눈에 안 보이는 객체 생성**에 주의.
- 단, **명확성과 안정성을 해치지 않는 선**에서만 최적화할 것.

---

**느낀 점 / 인사이트**

- 불변과 재사용은 같은 개념이 아니다.
- 작은 습관 하나(ex. 기본 타입 사용, 정적 캐싱)로도 큰 성능 차이를 만든다.
- 무조건 객체 생성을 피하는 것이 아니라, **언제 재사용이 의미 있는지 판단하는 능력**이 중요하다.

---

**다음 단계 제안**

- 다음 발표에서는 **아이템 50(방어적 복사)** 와의 비교를 더 깊게 다루고,
    
    실제 코드 리팩토링 사례를 통해 “언제 새 객체를 만들어야 하는가”를 탐구할 예정.
    

---
