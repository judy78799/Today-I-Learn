# 아이템_06_불필요한 객체 생성을 피하라

## new 연산자 vs String 불변객체

불변 클래스에서 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 막을 수 있다.

- 생성자는 호출할 때 마다 새로운 객체를 생성.
- 팩터리 메서드는 불변 객체 뿐만 아니라 가변 객체라 해도 사용 중에 변경 되지 않을 것 임을 안다면 재사용 가능.
- 생성 비용이 비싼 객체가 반복적으로 필요한 경우 캐싱해서 재사용할 것.

---

## 정규표현식으로 성능 더 끌어올리는 방법

문자열이 로마 숫자 형태인지 검사하는 코드.

```
static boolean isRomanNumeral(String s){
  String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
  return s.matches(regex);
}
```

## 발생 문제

- 성능 저하 : 정규식을 매번 새로 해석하고 컴파일 함.
- 불필요한 객체 생성 : Pattern과 Matcher 인스턴스를 계속 새로 만듦.
    - 성능이 중요한 상황에서 반복해서 사용하기란 적합하지 않음.
    - 메서드가 내부에서 만드는 정규표현식 Pattern 인스턴스는 한번 쓰고 버려져 GC 대상이 됨.
    - Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높음.

### 🔹 위의 코드 핵심인 s.matches(regex) 내부 동작을 살펴보자.

```
String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
Pattern p = Pattern.compile(regex);  // 정규표현식을 해석하고 내부적으로 FSM(유한 상태 머신)으로 변환. (👉 무거운 연산)
Matcher m = p.matcher(s);            // 해당 패턴으로 입력 문자열을 감싸는 Matcher 생성.
return m.matches();                  // FSM을 돌려서 문자열 전체가 패턴에 맞는지 검사.

```

=> isRomanNumeral 메서드를 호출할 때 마다 Pattern과 Matcher 객체가 매번 생성하고 있음.

**Pattern**

- java.util.regex.Pattern 클래스의 인스턴스.
- 문자열 형태의 정규식을 JVM이 이해할 수 있는 형태로 바꿔서 저장해둔 객체.

**Matcher**

- 문자열이 정규표현식 패턴과 일치하는지를 실제로 검사하는 실행기(executor)

---

## 🔷 인스턴스 생성 비용이 높음

- Pattern.compile(regex) :
- 정규식을 유한 상태 머신(FSM)으로 바꾸는 것은 단순한 문자열 파싱이 아님.
- 복잡한 분기/루프 구조(NFA)를 한 번 만들어놓음 → 비용이 큼(파싱 + 상태구조 생성).
- `패턴해석 -> 각 문자열의 전이 경로 계산 -> 루프(*, +), 조건(|), 그룹(()) 등을 다 처리해야 함.`

Pattern.compile(regex)의 복잡한 구조. (정규식 파싱 + NFA 상태기계 구조 생성)

```
[START] --(?=.)--> [S0]
[S0] --M--> [S0]        (M*)  (S0은 M 루프 상태)
[S0] --ε--> [H_START]   (hundreds 분기 시작)

# hundreds 분기 A (CM/CD)
[H_START] --'C'--> [H_A1] --'M' or 'D'--> [H_A_END]

# hundreds 분기 B (D? C{0,3})
[H_START] --ε--> [H_B0]
[H_B0] --'D'--> [H_B1]   (optional D)
[H_B0] --ε--> [H_B1]
[H_B1] --'C'--> [H_B2] --'C'--> [H_B3] --'C'--> [H_B4]
(각 H_B* 상태는 C{0,3} 반복)

# after hundreds
[H_A_END] --ε--> [T_START]
[H_B4]     --ε--> [T_START]

# tens 분기 (유사)
[T_START] --'X'--> ... (X[CL] branch)
or
[T_START] --ε--> ... (L? X{0,3} branch)

# ones 분기 (유사)
... --> [ONES_START]
[ONES_START] --'I' ... or --ε--> ... (V? I{0,3})

# 끝
[...] --> [ACCEPT] --(must be at end due to $)-->

```

- 정규식을 Pattern.compile()로 새로 컴파일 하여 Pattern 객체 생성.(NFA 구조)
- Matcher 객체를 생성 후 m.matches() 수행 → 매칭 결과 반환.
- 매칭 결과 반환 후 Pattern, Matcher 모두 GC 대상이 됨.
- 유한 상태 머신(Finite State Machine, FSM):

## 성능 개선 방법

- 필요한 정규식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성하여 캐싱.
- 나중에 isRomanNumeral 메서드가 호출될 떄마다 해당 인스턴스를 재사용.

값비싼 객체를 재사용해 성능을 개선하는 코드 예시.

```
public static RomanNumerals{
  private static final Pattern ROMAN = Pattern.compile(
    "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3}$");  //Pattern을 한번 생성하여 캐싱. 이후 객체 내부 FSM을 그대로 재사용하므로 빠름.

  static boolean isRomanNumeral(String s){  // 정적 유틸리티 메서드
    return ROMAN.matcher(s).matches();  // ROMAN 객체 재사용하여 정규식 검사 진행 -> true/false 반환.
  }
}

```

### 개선 효과

- 성능 개선 : 6.5배 정도 빨라짐. (길이가 8인 문자열)
- 코드의 의미가 잘 드러남 : 개선 전에서는 존재조차 몰랐던 Pattern 인스턴스를 static final 필드로 끄집어내고 이름을 지어주어 코드의 의미가 훨씬 잘 드러남.

### 정적 유틸리티 메서드 vs 정적 팩터리 메서드

| 구분 | 정적 유틸리티 메서드 (Static Utility) | 정적 팩토리 메서드 (Static Factory) |
| --- | --- | --- |
| 목적 | 특정 기능 수행, 계산, 검사 등 | 객체 생성 및 반환 |
| 반환 값 | 주로 primitive, boolean, void 등 | 항상 객체 인스턴스 |
| 객체 생성 | 기존 객체를 재사용할 수 있음, 새 객체 생성 필수 아님 | 새로운 객체 생성하거나, 캐시된 인스턴스 반환 가능 |
| 예시 | Math.max(a,b), Collections.sort(list), RomanNumerals.isRomanNumeral(s) | Integer.valueOf(42), LocalDate.of(2025,10,24) |

## “불변”과 “재사용 가능”은 항상 일치하지 않음.

객체가 불변인 경우 훨씬 덜 명확하거나, 심지어 직관에 반대되는 상황도 있음.

### 예시 1. 어댑터(Adapter) 객체

- 어댑터는 뒷단(backend) 객체에 요청을 위임하는 뷰(View) 역할을 함.
- 어댑터 자신이 관리하는 상태는 거의 없음 → 겉보기에는 불변처럼 보일 수 있음.
- 하지만 어댑터가 내부적으로 뒷단 객체에 접근하는 방식이나 캐싱, 임시 상태를 관리할 수도 있음.
주의점
- 뒷단 객체만 관리한다고 해서 완전히 안전하게 재사용할 수 있는 것은 아님.
- 만약 뒷단 객체가 상태를 변경한다면, 같은 어댑터를 여러 곳에서 재사용할 경우 상태 공유 문제가 생길 수 있음.
- 즉, 어댑터는 자체적으로는 불변이지만, 관리하는 뒷단 객체가 변할 수 있으면 재사용이 직관과 달리 안전하지 않을 수 있음.
- ✅ 결론: 어댑터 같은 경우 관리 대상 상태가 외부에 있으면, 겉보기 불변이라도 재사용에 주의해야 한다는 의미.

### 예시 2. Map 인터페이스의 keyset 메서드

```jsx
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

Set<String> keys1 = map.keySet();
Set<String> keys2 = map.keySet();
```

| **개념** | **설명** |
| --- | --- |
| **keySet()** | Map의 키 전체를 보여주는 **“뷰(View)” 객체** 반환 |
| **뷰(View)** | 원본 Map을 **감싸서 간접적으로 접근**하게 하는 객체 |
| **공유 구조** | map을 수정하면 keySet() 결과도 즉시 반영됨 |
| **특징** | 별도의 복사본이 아님, 실시간으로 원본과 연결됨 |

### **⚙️ 핵심**

- keySet()은 호출할 때마다 **새로운 Set을 복사해서 만들지 않는다.**
- 내부적으로는 **같은 Set 뷰를 반환하거나, 동일한 기능을 하는 새 뷰를 만들어도 결과는 동일**하다.
- 즉, 불필요하게 여러 객체를 만들 필요가 없음.

### 예시 3. 오토박싱（auto boxing）

오토박싱 : 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술

=> 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

```jsx
private static long sum() {
    Long sum = 0L; // ❌ Long (박싱 타입)
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;  // 매번 Long → long, long → Long 변환
    return sum;
}
```

### **⚠️ 문제점**

- sum이 **박싱 타입(Long)** 이기 때문에,
    
    sum += i; 연산 시 매번 새로운 Long 객체가 생성됨.
    
- 반복문이 약 21억 번 도는 동안 **21억 개의 Long 객체**가 만들어짐!

```jsx
private static long sum() {
    long sum = 0L; // ✅ 기본 타입 사용
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

**💨 성능 차이**

| **코드** | **실행 시간(대략)** |
| --- | --- |
| Long sum = 0L | **6.3초** |
| long sum = 0L | **0.59초** |

## 객체 생성은 비싸니 항상 피해야 한다. (❌)

- 요즘의 때에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다.
- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일임.

## 아주 무거운 객체가 아닌 이상 단순히 객체 생성을 피하고자 객체 풀(pool)을 만들지는 말자.

- 데이터 베이스 연결의 경우 -> 객체 생성 비용이 비쌈 -> 재사용 추천.
- 일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.
- 요즘 JVM의 가비지 컬렉터는 상당히 잘 최적화되어서 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.

## 아이템 6 <-> 아이템 50(방어적 복사(defensive copy))과 대조적인 주제.

- 아이템 6 : 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 말아라.
- 아이템 50 : 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라.
- 피해가 큰 정도 : 아이템 50(방어적 복사가 필요한 상황에서 객체를 재사용) >> 아이템 6(필요 없는 객체를 반복 생성)
- 방어적 복사에 실패하면 언제 터져 나올 지 모르는 버그와 보안 구멍으로 이어짐. 하지만 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 줌.
