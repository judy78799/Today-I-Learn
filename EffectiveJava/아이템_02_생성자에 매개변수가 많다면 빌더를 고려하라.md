# 생성자에 매개변수가 많다면 빌더를 고려하라

[선택 매개변수가 많을 때 활용할 수 있는 대안들]

## 1. 점층적 생성자 패턴 : 생성자(0 … n 매개변수){}

매개변수 개수가 많아질 수록 클라이언트 코드를 작성하거나 읽기 어려움(가독성)

---

## 2. 자바 빈즈 패턴 (Java Beans pattern)

```java
public class NutritionFacts{
	private int servingSize = -1;
	private int servings    = -1;
	private int calories    = 0;
	private int fat         = 0;
	private int sodium      = 0;
	private int carbohydrate = 0;
	
	public NutritionFacts(){}
	//setter methods
	public void setServingSize(int val)  {servingSize = val;}
	public void setServings(int val)     {servings = val;}
	public void setCalories(int val)     {calories = val;}
	public void setFat(int val).         {fat = val;}
	public void setSodium(int val)       {sodium = val;}
	public void setCarbohydrate(int val) {carbohydrate = val;}
	
	//자바빈즈패턴 인스턴스를 만들기 쉽고, 가독성이 좋다.
	NutritionFacts cocaCola = new NutritionFacts();
	cocaCola.setServingSize(240);
	cocaCola.setServings(8);
	cocaCola.setSodium(35);
	cocaCola.setCarbohydrate(27);
}
```

## 정의

> 매개변수가 없는 생성자로 객체 생성 후, Setter 메소드를 이용해 클래스 필드의 초깃값을 설정하는 방식.


```java
NutritionFacts cocaCola = new NutritionFacts();
	cocaCola.setServingSize(240);
	cocaCola.setServings(8);
	cocaCola.setSodium(35);
	cocaCola.setCarbohydrate(27);
```

### 자바빈즈 패턴의 단점

- 객체 하나를 만들기 위해 메서드를 n 번 호출해야 함.
- 일관성X : 객체가 완전히 생성되기 전에는 일관성이 무너진 상태.
- 불변X : 객체를 불변으로 만들 수 없음 + 스레드 안전성을 얻으려면 개발자가 추가 작업을 해줘야 함.

**일관성 깨진 경우 VS 일관성 지켜진 경우**

- 일관성이 지켜진 경우
    
    ```java
    public NutritionFacts(int servingSize, int servings, int calories) {
            this.servingSize = servingSize;
            this.servings = servings;
            this.calories = calories;
        }
    ```
    
    > **“생성 직후부터 유효한 상태를 가지며, 불변의 제약조건을 만족하는 객체”**
    > 
    - 생성된 순간부터 객체의 모든 필드가 유효하게 초기화되어 있고
    - setter로 바꿀 수 없는 (불변한) 상태면
        
        → 그 객체는 **일관성이 있는 객체(consistent object)**.
        
- 일관성이 깨진 경우
    
    ```java
    NutritionFacts nf = new NutritionFacts();   // (1) 아직  servingSize, servings 둘 다 '0'
    nf.setServingSize(28);     // (2) servingSize만 설정됨
    // (여기서 프로그램이 잠시 중단되면?)
    nf.setServings(27);          // (3) servings 설정
    nf.setCalories(190);         // (4) calories 설정
    ```
    
    - (1)~(4) 사이 동안 NutritionFacts 객체는 **불완전한 상태**.
    - servingSize만 있고 servings, calories가 없는, **일관성이 깨진(consistent하지 않은)** 상태.

---

## **3. 빌더 패턴 (점층적 생성자 패턴 안전성 + 자바 빈즈 패턴의 가독성)**

1) **필수 매개변수만으로** 생성자(정적 팩터리)를 호출해 빌더 객체를 얻는다.
2) 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정.
3) 매개변수가 없는 build 메서드를 호출해 필요한 객체를 얻는다. (불변)
빌더는 보통 생성할 클래스 안에 정적 멤버 클래스로 만들어둠

> 빌더패턴 ⇒ **명명된  선택적 매개변수를 흉내낸 것**
> 

```java
public class NutritionFacts{
	private final int servingSize;
	private final int servings;
	private final int calories;
	private final int fat;
	private fnal int sodium;
	private final int carbohydrate;
	
	public static class Builder{
	//필수 매개변수
	private final int servingSize;
	private final int servings;
	
	//선택 매개변수
	private int calories     = 0;
	private int fat          = 0;
	private int sodium       = 0;
	private int carbohydrate = 0;
	
	public Builder(int servingSize, int servings){
		this.servingSize = servingSize;
		this.servings    = servings;
	}
	
	public Builder calories(int val){
		calories = val;
		return this;
	}
	
	//기존 Setter와의 다른 특성을 가지고 있는 점을 알리기 위해서, set 단어는 빼주고 심플하게 멤버이름으로만 메서드명을 지어준다.
	public Builder fat(int val) {fat = val;      return this;}
	public Builder sodium(int val) {sodium = val;    return this;}
	public Builder carbohydrate(int val) {carbohydrate = val;    return this;}
	
	public NutritionFacts build() {return new NutritionFacts(this);}
	
	//불변 클래스 - 모든 매개변수의 기본 값들을 한 곳에 모아뒀음.
	//빌더의 세터 메서드들은 빌더 자신을 반환하여 연쇄적으로 호출 가능.
	private NutritionFacts(Builder builder){
		servingSize = builder.servingSize;
		servings = builder.servings;
		calories = builder.calories;
		fat = builder.fat;
		sodium = builder.sodium;
		carbohydrate = builder.carbohydrate;
	}
	}
}
```

빌더 클래스 클라이언트 코드

- 쓰기 쉽고 읽기 쉽다. 👍
- 빌더 패턴은 **명명된 선택적 매개변수(파이썬, 스칼라)를 모방한 것.
    - **명명된 선택적 매개변수?
        
        ```python
        def user_info(name, age=20, city="Seoul"):
            print(f"{name}, {age}, {city}")
        
        user_info("Judy")                   # 기본값 사용
        user_info("Judy", city="Busan")     # 명명된 선택적 매개변수 사용
        ```
        
        ➡ age, city가 선택적이고,
        
        city="Busan"처럼 **이름을 붙여서 호출 가능.**
        

```java
NutritionFacts cocaCola = new NutritionFacts.Builder(240,8)
				.calories(100).sodium(35).carbohydrate(27).build();
```

**[빌더패턴에서의 디버깅 방법]**

- 빌더의 생성자와 메서드에서 입력 매개변수를 검사
- build 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식을 검사하기.
- 불변식을 보장하려면 빌더로부터 매개변수를 복사한 후 해당 객체 필드들을 검사해야함.
- 검사 후 잘못된 점 발견 → 어떤 매개변수가 잘못되었는지 자세한 메시지 + `IllegalArgumentException` 예외 던지기

빌더패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.

- 계층적으로 설계된 클래스 예시
    
    > **상속 구조로 설계된 클래스**
    > 
    
    공통 속성
    
    ```java
    public abstract class Pizza {
        private final Set<String> toppings;
    
        abstract static class Builder<T extends Builder<T>> {
            Set<String> toppings = new HashSet<>();
            public T addTopping(String topping) {
                toppings.add(topping);
                return self();
            }
            abstract Pizza build();
            protected abstract T self(); // 하위 클래스에서 this 반환
        }
    
        Pizza(Builder<?> builder) {
            toppings = Set.copyOf(builder.toppings);
        }
    }
    ```
    
    세부 확장
    
    ```java
    public class NyPizza extends Pizza {
        public enum Size { SMALL, MEDIUM, LARGE }
        private final Size size;
    
        public static class Builder extends Pizza.Builder<Builder> {
            private final Size size;
            public Builder(Size size) { this.size = size; }
    
            @Override public NyPizza build() { return new NyPizza(this); }
            @Override protected Builder self() { return this; }
        }
    
        private NyPizza(Builder builder) {
            super(builder);
            size = builder.size;
        }
    }
    ```
    

공변 반환 타이핑 : 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능 → 클라이언트가 형변환에 신경 쓰지 않고도 빌더를 사용할 수 있음.

### 빌더 패턴의 장점

- 유연함 : 빌더 하나로 여러 객체를 순회하면서 만들 수 있고 빌더에 넘기는 매개변수에 따라 다른 객체를 만들 수도 있음.

### 빌더 패턴의 단점

- 객체를 만들기 위해서 빌더 부터 만들어야 함. 코드 복잡성 증가.
- 성능에 민감한 상황에서는 빌더 생성 비용이 문제가 될 수 있음. (생성자 패턴보다 성능 떨어짐)
- 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 함.
(API는 시간이 지날수록 매개변수가 많아지는 경향이 있음을 명심할 것)
- 생성자나 정적팩터리 방식 → 나중에 매개변수 많아질 경우 빌더 패턴으로 전환할 수 있음.
⇒ 애초에 빌더로 시작하는 편이 나을 떄가 많다.

## Summary

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하자.
특히 매개변수 중 다수가 필수가 아니거나 같은 타입인 경우!
