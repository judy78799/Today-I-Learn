# ✅ 서버리스 개념

> 서버가 없다 → 우리가 직접 서버를 관리하지 않아 신경 쓸 필요가 없는 경우
> 
- 사이드 프로젝트나 빠르게 프로토타입을 출시할 때 빠르고 쉽게 제품을 출시할 수 있음.
- 돈도 절약할 수 있음.

# 🔷 탄생 배경

### 온 프레미스(On-Premise)

- 직접 서버를 설치하는 것. 라즈베리파이 등
- 하드웨어 구입하고 거실에 놓고 전원을 직접 가동시키고,,소프트웨어를 하드웨어에 업로드해 서비스를 운영
- ⇒ 즉 하드웨어 부분(라즈베리 파이)과 소프트웨어 부분 둘 다 직접 관리

> 😫 개발자는 코딩하기도 바빠 죽겠는데 하드웨어 관리가 힘들어!!
> 

→ 차라리 서버 컴퓨터를 임대할게

⇒ 🚼 클라우드 기술 탄생

---

# 🔷 클라우드(IaaS/ PaaS)

> 돈만 내면 최신식 서버를 빌려서 사용할 수 있다.
> 

⚠️ 하지만 여전히 서버의 소프트웨어 적인 부분은 사용자가 직접 관리해야 함.

- 서버에 깔린 운영체제 등을 업데이트
- 데이터 백업
- 보완에 신경써야 함

⇒ 하드웨어 적인 부분만 빌리는 거고 서버 자체는 텅 비어있음

서버를 돌리려면 이것저것 소프트웨어를 설치 및 업데이트, 관리해야 함.

### IaaS PaaS

- 실제 사용자에 관계없이 미리 결제한 용량에 따라 요금을 내야 함.
- 사용자가 0명이든 1000명이든 관계없이 같은 금액을 내야 함.

- 아무리 On-demand  쓴만큼 지불하는 서비스를 이용하더라도 
대부분의 클라우드 서비스들은 
사용자들이 내 서버를 사용하지 않더라도 그냥 가동만 시켜도 
시간마다 결제가 되는 시스템임. 싯팔 AWS,,
- 크던 작던 손실을 일으키게 됨.

# 🔷 서버리스 등장

### 서버리스 컴퓨팅 개념

클라우드 서비스 업체가 특정 코드를 실행하는 데 필요한 컴퓨팅 리소스와 스토리지만 동적으로 할당한 다음 그 부분에 대해서만 비용을 청구하는 클라우드 실행모델

### ✅ 서버리스 원리

개발자가 서버리스에 업로드한 함수는 24시간 내내 돌아가는 게 아닌 휴먼 상태에 들어간다.

그러다가 사용자 요청이 오는 순간 서버리스는 잠들어 있는 함수를 깨우고 실행시켜 요청한 작업을 수행하게 한다. 그리고 다시 함수는 잠들게 한다.

→ 대기 상태를 제외한 실제 사용자원에 대해서만 청구가 됨. 경제적 + 효율적임 (퍼포먼스 측면에도 문제가 없음. 유저가 늘어나면 그 만큼 함수도 늘리는 식으로 처리함.)

ex. AWS Lamda : 백만개의 함수 실행을 단돈 20센트밖에 안듦.

### ☀️ 서버리스 활용 시,

백엔드를 서버에 올리는 것이 아닌, 작은 함수 단으로 쪼개서 아마존에서 직접 관리하는 서버로 올리게 됨.

→ 서버는 클라우드 제공 기업에서 전적으로 관리함. 사용자는 스케일링, 업데이트, 보왼 등 런타임관리 + 운영에 대해 시간을 소모하지 않고 핵심 제품에 집중할 수 있음.

→ 개발자는 시간과 에너지 확보 가능

# 🔷 서버리스 모델 BaaS/FaaS

## 💠 BaaS(Backend as a Service)

보통 데이터를 저장하고, 다른 기기에서도 접근하고 공유하기 위해서 백엔드 서버 개발을 진행하게 됨.

### 🔶 탄생배경

서버 개발을 하다보면 고려할 사항이 꽤 많아짐. 

유저가 늘어나게 된다면 서버의 확장도 고려해야 함.

앱 개발에 있어서 필요한 다양한 기능들(데이터베이스, 소셜서비스 연동, 파일시스템 등)을 API로 제공해줌으로서, 

개발자들이 서버 개발을 하지 않고서도 필요한 기능을 쉽고 빠르게 구현할 수 있게 해줌. 비용은 API 사용 한 만큼 나가는 원리임.

서버의 이용자가 순식간에 늘어나도 알아서 확장이 된다.

### 🔶 장점

개발 시간의 단축(회사 입장에서는 인건비), 서버 확장 작업의 불필요함

### 🔶 대표적인 서비스

Firebase

- 실시간 데이터베이스를 사용하여 데이터가 새로 생성되거나 수정되었을 때 소켓을 사용하여 클라이언트에게 바로 반영시켜주는 기능
- 코드 몇 줄로 구현 가능(구조 설정 필요 X)

## 💠 Faas(Function as a Service)

- 함수(프로그래밍 수준에서 Function or 메소드)를 서비스로 제공한다.
- 사용자는 Rest API와 같은 HTTP 요청을 통해 함수를 호출하고 원하는 파라미터를 전달하여
- 함수가 리턴 값이 있다면 리턴 값을 받거나 혹은 함수의 동작 시작 이벤트를 발생시킬 수 있다.

⇒ S/W 개발자와 IT 업계가 프로그래밍 로직에만 집중할 수 있다.

### 🔶 대표적인 서비스

- AWS Lambda
- MS Azure Function

### 🔶 FaaS 생성 단계

![image.png](attachment:76da6573-ebb3-444b-998d-3f934aaa4fd2:image.png)

1. 사용자는 자신의 프로그램 내부에서 FaaS 함수를 호출하는 구문을 삽입하고 프로그램을 실행하게 되면, 
FaaS에게 Rest API 형식의 HTTP 요청이 가게 된다.
2. 그럼 FaaS는 해당 함수를 저장소로 부터 읽어오게 되고
3. 해당 함수를 컨테이너 혹은 가상머신으로 생성하게 된다.
4. 다음 함수를 포함하고 있는 컨테이너 혹은 가상머신이 생성이 만료되면 함수를 실행하고 결과를 반환하거나 함수가 수행해야 하는 동작을 수행하게 된다.
5. 이후 일정시간 동안 함수의 호출이 없다면 함수를 포함하는 컨테이너 혹은 가상머신은 FaaS 시스템에 의해 삭제된다.

## 💠 BaaS vs FaaS

### BaaS 서비스

- 애플리케이션 개발 시 요구되는 **복잡한 백엔드 기능**들을 개발자가 직접 개발하지 않고 클라우드 공급자가 제공하는 서비스를 이용해 쉽고 안정적으로 구현 하는 것
- 서비스 제공자로부터 **미리 만들어진 백엔드 API를 제공받아** 사용하는 형태
- 데이터 저장 및 로드, 사용자 인증, 메시징, 소셜 서비스 등의 백엔드 기능을 완성된 API로 사용할 수 있다.

### FaaS 서비스

- 개발자가 사용자 정의 서버 측 로직을 작성하지만 클라우드 제공 업체가 관리를 전담하는 서버 컨테이너에서 실행 되는 서비스 기능
- 서버에서 수행될 기능들을 개발자가 직접 코드로 작성하여 등록한다.
- 실행 가능한 코드(함수)를 미리 등록해놓았다가 특정 이벤트(트리거)가 발생하면 알아서 호출 및 종료되도록 한다.
- PaaS는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 항상 실행되지만, 
FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며 작업을 마치거나 일정 시간이 지나면 종료된다는 차이점이 있다.
- 호출한 함수의 횟수와 실행 시간에 따라 비용을 지불한다.

---

# 🔷 서버리스 장단점

## 💠 서버리스 장점

### 1 비용 절감

1. 기존 IaaS나 PaaS와는 다르게 실제 사용량에 대해서만 비용이 청구되므로 경제적이다.
2. 이벤트 기반의 비용으로, 일정 주기, 조건 등에 함수를 호출하므로 리소스를 낭비하지 않게 되어서 비용이 저렴하다. (AWS Lambda의 경우 함수 100만번 실행 당 0.2달러)
3. 자체 서버를 실행하고 관리하는 대신 필요한 만큼 클라우드 기반 컴퓨팅 시간에 대해 비용을 지불

### 2 애플리케이션의 품질에 집중 가능

1. 서버에 신경 쓸 필요가 없어지므로 사용자는 개발하는 애플리케이션의 품질 향상에 좀 더 집중할 수 있다.

### 3 높은 가용성과 유연한 확장

1. 요청이 들어올 때만 실행되고 동적으로 자원을 할당하기 때문에 가용성이 높고 스케일링에 신경쓸 필요가 없다.

### 4 빠른 개발 배포

1. 간단한 패키징 및 배포
2. 릴리즈 주기 감소
3. 높은 생산성
4. 유지보수나 기능추가에 효율적이라 관리보다 개발에 집중할 경우

## 💠 서버리스 단점

### 1 Cold Start

- 서버리스의 함수들은 요청이 없으면 수면 상태로 된다.
그라다 만일 request가 와서 함수를 깨우고 실행하는데 아무래도 시간이 걸린다.
물론 1밀리초로 사람이 인지하기에 아주 짧은 시간이겠지만, 만일 0.01초라도 지연을 허용되지 않는 서비스일 경우는 서버리스는 좋은 선택이 아니다.
- 즉, 아무래도 서버가 항시 요청에 대기하고 있는게 아니다보니 IaaS나 PaaS등의 모델보단 요청시간이 느리다.
- 실시간 서비스에는 적합하지 않음
- 프로젝트 규모가 작다면 별로 신경쓸만한 사항은 아니지만 규모가 커지거나 속도를 요구하는 프로젝트라면 서버리스는 좋은 선택이 아닐 수 있다.

### 2 긴 시간을 요하는 작업에 불리함

- 서버리스는 단순 작업(댓글 쓰기, 이메일 보내기 등)에는 적합하지만, 긴 시간을 요하는 작업(동영상 업로드, 데이터 백업 등)에는 굉장히 비효율적이다.
- 서버리스는 함수가 1회 호출 될 때 사용할 수 있는 메모리 및 시간에 제한이 있기 때문이다. 이에 따라 큰 기능을 잘게 나누어 구현해야 한다.

### 3 로컬 데이터를 사용할 수 없다.

- 서버리스는 무상태(Stateless)적인 기능으로 구현되어야 한다.
- 하나의 작은 기능으로 나뉘어진 함수들은 요청마다 새로 기동되어 호출되기 때문에 전후 상태를 공유할 수 없기 때문이다.
- 또한 변수와 데이터의 공유가 불가능하며, 데이터를 로컬 스토리지에서 읽고 쓸 수 없다. (이는 서버리스 벤더에 따라 추가 서비스를 통해 극복이 가능하지만, AWS S3, Azure Storage등 일반적인 서버리스는 불가능하다.)

### 4 클라우드 제공 플랫폼에 심하게 종속적

- 기존 IaaS나 PaaS모델은 플랫폼을 바꾸는게 어렵지 않지만(ex. AWS에서 Google Cloud로) 서버리스는 애플리케이션의 구조 자체를 바꾸기 때문에 다른 플랫폼으로 이전하는게 굉장히 힘들다.
- 이를 클라우드 서비스 업체에 종속적이라고 일컫는다.
- 이는 곧 사용중인 플랫폼의 가격이나 정책, 서비스 변경에도 민감하게 반응해야됨을 의미한다. 제공업체를 변경하면 새로운 벤더 사양에 맞추기 위해 시스템을 업그레이드하는 비용이 발생할 수도 있다.

---

## 🔷 FaaS(Function as a service)

- 서버리스 아키텍처에서 백엔드 코드는 FaaS를 활용하여 개발할 수 있음.
- 특정 이벤트가 발생했을 때만 함수가 실행되는 방식을 의미.
    - ex. GET /hello 라는 API 경로에 호출이 발생했을 때, 이를 처리할 수 있는 함수를 잠시 실행하고 결과를 클라이언트에 응답함.

개발자는 비즈니스 로직을 작성하고, 클라우드 인프라에 코드 조각(함수)을 배포하면 됨.

## 🔷 BaaS(Backend as a service)를 활용할 수 있음.

- 클라우드 제공업체에서 만든 인증, 소셜 서비스 등의 완성된 백엔드 기능을 사용할 수 있음.
- ex. Firebase Authentication을 활용하면 비교적 적은 코드로 로그인 기능을 구현할 수 있음.
