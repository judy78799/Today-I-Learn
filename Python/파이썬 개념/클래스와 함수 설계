## 1. 클래스와 함수 설계 — SRP(단일 책임 원칙) + 프로젝트 활용

핵심: 하나의 클래스/함수는 하나의 책임만 가져야 한다. 책임 분리가 테스트·유지보수·재사용성의 핵심.

### 왜 중요한가
	•	서비스는 비즈니스 로직, 저장소는 DB 접근, 컨트롤러는 HTTP 입출력 — 역할이 분리돼야 각 계층을 독립적으로 테스트/교체 가능.
	•	의존성 주입(DI)을 통해 테스트에서 외부 리소스를 모킹할 수 있다.

### 권장 구조 (레이어)
	•	Controller (FastAPI route): 입력 검증, 응답 변환, 에러 매핑
	•	Service: 도메인 로직 (비즈니스 규칙)
	•	Repository/DAO: DB 쿼리/영속성
	•	Utils: 순수 함수, 변환기, 스플리터 등

### 설계 팁
	•	__init__에서는 생성·설정만 하고 네트워크/IO 호출을 하지 마라. (초기화 중 실패 시 복구 어려움)
	•	상태 공유를 최소화. 불가피하면 불변(immutable) 또는 명시적 락을 사용.
	•	메서드는 작고 단일 목적. return 값이 명료해야 함(예: dict vs custom DTO).
	•	에러는 예외로 올바르게 전파하고, 컨트롤러에서 HTTP 상태로 매핑.

예: 안 좋은 패턴
```
class BadTemplateGenerator:
    def __init__(self):
        self.client = SomeRemoteClient()  # 네트워크 호출이 init에서!
```
좋은 패턴 (DI)
```
class TemplateGenerator:
    def __init__(self, openai_client, chroma_service):
        self.openai = openai_client
        self.chroma = chroma_service

    def generate(self, prompt: str) -> str:
        # 비즈니스 로직만
        ...
```

이렇게 하면 단위 테스트에서 openai_client를 모킹하면 됨.

### 타입/값 객체
	•	dataclasses(또는 NamedTuple)로 DTO/Value Object 표현 (frozen=True로 불변 권장).
	•	인터페이스 대신 추상 베이스 클래스(ABC)로 타입 기대치 설정.

## 2. 컨텍스트 매니저 — 자원 안전 확보의 정석

핵심: 리소스(open files, DB sessions, locks, subprocesses)는 항상 닫아야 한다. with가 가장 안전.

기본 사용
```
with open(path, 'r', encoding='utf-8') as f:
    for line in f:
        ...
```

DB/트랜잭션(예: SQLAlchemy)
```
from contextlib import contextmanager

@contextmanager
def session_scope(Session):
    session = Session()
    try:
        yield session
        session.commit()
    except:
        session.rollback()
        raise
    finally:
        session.close()
```

예: 타이머(디버깅/로깅용)
```
from contextlib import contextmanager
import time

@contextmanager
def timer(name="block"):
    start = time.time()
    try:
        yield
    finally:
        print(f"{name} took {time.time()-start:.3f}s")
```

ExitStack / AsyncExitStack
	•	여러 컨텍스트를 동적으로 관리할 때 유용(파일 여러 개, 동적 리소스).

## 3. 리스트 컴프리헨션 vs 제너레이터 — 성능·메모리·가독성 관점

핵심: 리스트 컴프리헨션은 메모리에 결과를 다 올리지만(빠름), 제너레이터는 게으르게(lazy) 평가해 메모리 절약.

속도
	•	단순한 변환에서 리스트 컴프리헨션이 일반 for 루프보다 빠름(내부적으로 C 레벨).
	•	하지만 입력이 매우 클 경우 메모리 때문에 제너레이터를 사용해야 함.

예:
```
# 리스트 컴프리헨션 (즉시 평가)
squares = [x*x for x in range(10_000)]

# 제너레이터 (lazy)
squares_gen = (x*x for x in range(10_000))
```

실전 패턴 — 파이프라인(대용량 처리)
	•	파일 → 텍스트 청킹 → 배치화 → 임베딩 → DB 저장
	•	각 단계는 제너레이터로 구현하면 메모리 오버플로우 방지 가능.


배처(batch) 제너레이터 예:
```
def batcher(iterable, batch_size):
    batch = []
    for item in iterable:
        batch.append(item)
        if len(batch) >= batch_size:
            yield batch
            batch = []
    if batch:
        yield batch
```

제너레이터 함수 예 (청킹 파이프라인):
```
def read_lines(path):
    with open(path, 'r', encoding='utf8') as f:
        for line in f:
            yield line.strip()

def split_documents(lines):
    for line in lines:
        doc = process_line(line)  # 순수 함수
        for chunk in chunker(doc):
            yield chunk

for batch in batcher(split_documents(read_lines(path)), 100):
    embeddings = embed_model.embed(batch)
    db.insert_bulk(embeddings)
```

주의사항
	•	리스트 컴프리헨션 안에서 사이드 이펙트(로깅, DB 쓰기) 하면 가독성/디버깅이 어려움 — 그런 경우 명시적 for가 낫다.
	•	중첩 컴프리헨션은 가독성 저하. 적절히 잘게 나누자.

타입 힌트
```
from typing import Iterator, Iterable, List
def split_documents(docs: Iterable[str]) -> Iterator[str]: ...
```

## 4. 동시성·안전성(백엔드 관점)
	•	I/O 바운드: asyncio 또는 ThreadPoolExecutor 사용. CPU 바운드: ProcessPoolExecutor.
	•	공유 자원(클라이언트, 세션 등)은 문서화된 thread-safety 보장 여부를 확인. 보장 안 되면 각 작업마다 새 인스턴스 또는 풀(pool) 사용.
	•	비동기 코드에서는 async with와 asyncio.Semaphore로 동시호출 수 제어(레이트 리밋)에 유의.

## 5. 테스트·유지보수
	•	작은 단위 함수로 분리하면 유닛 테스트가 쉬움.
	•	서비스는 외부 의존성을 주입(DI)해서 모킹 가능.
	•	pytest fixture로 임시 DB, temp file, monkeypatch env를 준비.
	•	타입 검사(mypy), 정적분석(ruff, flake8), 포맷(black)을 CI에 추가.

## 6. 체크리스트(프로젝트에서 써볼 항목)
	•	__init__는 가벼운 초기화만. 네트워크 호출 X.
	•	리소스는 항상 context manager로 관리.
	•	대용량 데이터는 제너레이터 + batcher로 처리.
	•	함수는 한 가지 일만 하게 설계(SRP).
	•	외부 클라이언트는 thread/async-safe인지 문서 확인.
	•	복잡한 리스트 컴프리헨션 대신 가독성 우선(동료가 읽기 쉬운 코드).
	•	모든 외부 호출(네트워크, DB)은 재시도·타임아웃·로깅 정책 적용.

