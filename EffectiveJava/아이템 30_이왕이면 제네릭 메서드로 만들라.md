# 아이템 30_이왕이면 제네릭 메서드로 만들라.

---

## 🟦 1. 서론 (Intrduction)

### 🎯 발표 목적

- **제네릭 메서드의 중요성**과 올바른 사용법을 이해합니다.
- 타입 안전성을 보장하면서도 유연한 코드를 작성하는 방법을 학습합니다.
- 실무에서 자주 발생하는 제네릭 관련 경고를 해결하는 방법을 배웁니다.

### ❓ 배경 / 문제 인식

- 클래스와 마찬가지로, **메서드도 제네릭으로 만들 수 있습니다**.
- 매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭입니다.
    - 예: `Collections`의 `binarySearch`, `sort` 등 모든 알고리즘 메서드
- **Raw 타입 사용 시** 컴파일러 경고가 발생하고 타입 안전성이 떨어집니다.

### 🎓 목표 / 기대 효과

- 제네릭 메서드를 작성하여 타입 안전성을 확보합니다.
- 코드의 재사용성과 유연성을 높입니다.
- 불필요한 형변환을 제거하고 컴파일 타임에 타입 오류를 잡을 수 있습니다.

---

## 🟨 2. 본론 (Main Content)

### 1️⃣ 문제가 있는 코드 예시

### 📌 코드 30-1: Raw 타입 사용 - 수용 불가!

```java
public static Set union(Set s1, Set s2) {
    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}

```

**문제점:**

- Raw 타입 사용으로 인한 컴파일러 경고 발생
- 타입 안전성이 보장되지 않음
- 런타임에 `ClassCastException` 발생 가능

**컴파일러 경고 메시지:**

```
Union.java:5: warning: [unchecked] unchecked call to HashSet(Collection<? extends E>) as a member of raw type HashSet

```

---

### 2️⃣ 제네릭 메서드로 개선

### ✅ 코드 30-2: 제네릭 메서드

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}

```

**개선 사항:**

- 타입 매개변수 `<E>`를 메서드 선언에 추가
- 경고 없이 컴파일됨
- 타입 안전하고 사용하기 쉬움

### 📝 코드 30-3: 제네릭 메서드 활용 예

```java
public static void main(String[] args) {
    Set<String> guys = Set.of("톰", "딕", "해리"); // 정적 팩토리 메서드로, 주어진 요소들을 포함하는 불변(Immutable)의 Set 객체를 생성
    Set<String> stooges = Set.of("래리", "모", "컬리");
    Set<String> aflCio = union(guys, stooges); // guys와 aflCio를 합침.
    System.out.println(aflCio);
}

```

**출력 결과:**

```
[모, 톰, 딕, 해리, 래리, 컬리]
```

---

### 3️⃣ 제네릭 싱글턴 팩터리 패턴

불변 객체를 여러 타입으로 활용할 수 있게 만드는 패턴입니다.

### 📌 코드 30-4: 제네릭 싱글턴 팩터리 패턴

```java
private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;

@SuppressWarnings("unchecked")
public static <T> UnaryOperator<T> identityFunction() {
    return (UnaryOperator<T>) IDENTITY_FN;
}

```

**핵심 원리:**

- `IDENTITY_FN`은 `UnaryOperator<Object>`로 형변환하면 비검사 형변환 경고가 발생합니다.
- 하지만 항등함수는 입력 값을 그대로 반환하므로 타입 안전합니다.
- `@SuppressWarnings("unchecked")`로 경고를 숨깁니다.

### 📝 코드 30-5: 제네릭 싱글턴 사용 예

```java
public static void main(String[] args) {
    String[] strings = { "삼베", "대마", "나일론" };
    UnaryOperator<String> sameString = identityFunction();
    for (String s : strings)
        System.out.println(sameString.apply(s));

    Number[] numbers = { 1, 2.0, 3L };
    UnaryOperator<Number> sameNumber = identityFunction();
    for (Number n : numbers)
        System.out.println(sameNumber.apply(n));
}
```

---

### 4️⃣ 재귀적 타입 한정 (Recursive Type Bound)

자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정합니다.

### 📌 Comparable 인터페이스와의 관계

```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

- 타입 매개변수 `T`는 `Comparable<T>`를 구현한 타입이 비교할 수 있는 원소의 타입을 정의합니다.
- 실제로 거의 모든 타입은 자신과 같은 타입의 원소와만 비교할 수 있습니다.
- 예: `String`은 `Comparable<String>`, `Integer`는 `Comparable<Integer>` 구현

### ✅ 코드 30-7: 재귀적 타입 한정을 이용한 최댓값 계산

```java
public static <E extends Comparable<E>> E max(Collection<E> c) {
    if (c.isEmpty())
        throw new IllegalArgumentException("컬렉션이 비어 있습니다.");

    E result = null;
    for (E e : c)
        if (result == null || e.compareTo(result) > 0)
            result = Objects.requireNonNull(e);

    return result;
}

```

**타입 한정 의미:**

- `<E extends Comparable<E>>`: "모든 타입 E는 자신과 비교할 수 있다"
- 리스트의 모든 원소가 상호 비교 가능해야 함
- 타입 안전성이 컴파일 타임에 보장됨

---

### 5️⃣ 핵심 정리: 장점과 주의사항

### ✅ 장점

| 항목 | 설명 |
| --- | --- |
| **타입 안전성** | 컴파일 타임에 타입 체크, ClassCastException 방지 |
| **코드 재사용성** | 여러 타입에 대해 동일한 로직 적용 가능 |
| **가독성** | 명시적 형변환이 불필요하여 코드가 깔끔함 |
| **유연성** | 다양한 타입을 처리할 수 있는 범용 메서드 작성 가능 |

### ⚠️ 주의사항

- Raw 타입 사용을 피하고 항상 제네릭 타입을 명시합니다.
- 불필요한 `@SuppressWarnings("unchecked")`는 지양하되, 안전성이 확실할 때만 사용합니다.
- 재귀적 타입 한정 사용 시 타입 관계를 명확히 이해해야 합니다.

---

## 🟩 3. 요약 (Summary / Conclusion)

### 📌 핵심 포인트 요약

> "타입과 마찬가지로, 메서드도 제네릭으로 만들 수 있다."
> 
1. **제네릭 메서드는 더 안전하고 사용하기 쉽습니다.**
    - 클라이언트에서 직접 형변환하는 메서드보다 제네릭 메서드가 우월합니다.
2. **형변환 없이 사용할 수 있는 메서드가 더 좋습니다.**
    - 그러려면 제네릭 메서드가 되어야 합니다.
3. **제네릭 싱글턴 팩터리 패턴**으로 불변 객체를 여러 타입에서 재사용할 수 있습니다.
4. **재귀적 타입 한정**을 통해 타입의 자연적 순서를 정하는 `Comparable` 인터페이스와 함께 사용됩니다.

### 💡 느낀 점 / 인사이트

- 제네릭은 단순히 컬렉션에만 사용되는 것이 아니라, **메서드 설계에서도 핵심적인 역할**을 합니다. (타입 안정성을 확보할 수 있습니다.)
- 메서드를 제네릭으로 사용함으로서 타입 안전성을 컴파일 타임에 보장함으로써 **런타임 오류를 예방**할 수 있습니다.
- 잘 설계된 제네릭 메서드는 **API의 유연성과 안전성을 동시에 확보**합니다.

---
