# 아이템_05_자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 아래와 같은 클래스를 사용하지 않는 것이 좋다.
- 해당 자원을 클래스 내부에서 직접 생성하게 하는 것도 안된다.
- 대신 필요한 자원(혹은 그 자원을 넘겨주는 팩터리를)을 생성자에 (혹은 정적 팩터리나 빌더에)넘겨주자.
- 기대효과 : 의존 객체 주입을 사용하여 클래스의 유연성, 재사용성, 테스트 용이성을 개선해준다.

## 🚨 정적 유틸리티와 싱글턴 방식의 문제점
- 많은 클래스가 하나 이상의 자원에 의존하는데 정적 유틸리티, 싱글턴과 같은 방식으로는 객체를 하나 생성하여 재사용하는 것이므로
사전 객체 하나로 이 모든 쓰임에 대응할 수 없다.
- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
- 유연하지 않고 테스트하기 어렵다.

<br>

- 정적 유틸리티를 잘못 사용한 예 
```
public class SpellChecker{
  private static final Lexicon dictionary = ...;

  private SpellChecker() {} //객체 생성 방지

  public static boolean isValid(String word){...}
  public static List<String> suggestions(String typo) {...} 
}
```
### 정적 유틸리티
- 인스턴스를 만들 필요 없이 사용하는 클래스.(static 메서드만 사용)
- 모든 메서드가 static으로 선언되어 있고, 객체 상태를 가지지 않음.
- ex. java.lang.Math
```
public final class Math {
    private Math() {} // 인스턴스화 방지

    public static int max(int a, int b) {
        return (a >= b) ? a : b;
    }

    public static double sqrt(double a) {
        ...
    }
}

//호출 시
Math.max(3, 5);
Math.sqrt(9);
```

---

- 싱글턴을 잘못 사용한 예
```
public class SpellChecker{
  private final Lexicon dictionary = ...;

  private SpellChecker()  // 외부에서 인스턴스 생성 경로를 통제
  public static SpellChecker INSTANCE = new SpellChekcer();  // 외부에서 단 하나의 인스턴스에 접근할 수 있도록 함

  public boolean isValid(String word){...}
  public List<String> suggestions(String typo){...}
}
```
### 싱글턴
- 객체는 하나만 존재하는 관리형 인스턴스
### 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식을 사용하라.

### 싱글턴 vs 정적 유틸리티 
|구분|정적 유틸리티 클래스|싱글턴|
|---|---|---|
|인스턴스|없음|단 하나 존재|
|상태 보유|불가능|가능|
|다형성|불가능 (상속 X)|가능 (인터페이스 구현 가능)|
|사용 방식|ClassName.method()|Instance.method()|

## 의존 객체 주입 패턴
- 생성자, 정적 팩터리(아이템 1), 빌더(아이템 2) 모두에 똑같이 응용할 수 있다.
- 의존 객체란 아래 코드에서 Lexicon 타입의 dictionary를 일컬음.
```
public class SpellChecker{
  private final Lexicon dictionary;

  public SpellChecker(Lexicon dictionary){
    this.dictionary = Objects.requireNonNull(dictionary);
  }

  public boolean isValid(String word) {...}
  public List<String> suggestions(String typo) {...}
}
```
- 의존 객체 주입 패턴 : 아주 단순하여 많은 프로그래머가 이 방식에 이름이 있다는 것도 모른채 사용해왔었음.

## 의존 객체 주입 패턴 변형
- 생성자에 자원 팩터리를 넘겨주는 방식
- 팩터리 : 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체
- 즉, 팩터리 메서드 패턴(Factory Method pattern)[Gamma95]을 구현
- "Supplier<T> 인터페이스"가 팩터리를 표현한 완벽한 예
Supplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드 카드 타입을 사용해 팩터리 타입 매개변수를 제한해야 함.
이 방식을 사용하여 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩터리를 넘길 수 있음.

클라이언트가 제공한 팩터리가 생성한 타일들로 구성된 모자이크를 만드는 메서드.
```
Mosaic create (Supplier<? extends Tile> tileFactory) {...}
```
## ⚠️ 의존 객체 주입의 한계
- 의존성이 수천 개나 되는 큰 프로젝트에서는 코드의 가독성이 낮아질 수 있음.
- -> 의존 객체 프레임워크를 사용하면 문제 해결에 도움이 됨.
- ex. Spring, Guice, Dager 과 같은 의존 객체 프레임워크를 사용해 볼 것.
- 해당 프레임워크는 의존 객체를 직접 주입하도록 설계된 API를 알맞게 응용하여 사용하고 있음.
