## 🧩 구조적 서브 타이핑
- 타입의 이름이 아니라 구조(모양)가 같거나 호환되면 같은 타입으로 취급하는 규칙.
- 객체의 프로퍼티를 바탕으로 타입을 구분.
- 공통된 프로퍼티가 있으면 호환 가능. (다른 타입이더라도)

## 🧩 구조적 서브 타이핑 vs 명목적 타이핑 

|구분|구조적 서브타이핑 (Structural Subtyping)|명목적 타이핑 (Nominal Typing)|
|---|---|---|
|판단 기준|타입의 구조 (어떤 속성과 메서드를 가졌는가)|타입의 이름 (명시적으로 선언된 이름)|
|특징|이름이 달라도 구조가 같으면 호환 가능|구조가 같아도 이름이 다르면 다른 타입으로 취급|
|장점|유연성이 높고, 코드 재사용에 유리함|타입의 의도가 명확하고, 실수를 방지하기 쉬움|
|단점|의도치 않은 타입 호환이 발생할 수 있음|상속 관계를 명시해야 하므로 번거로울 수 있음|
|주요 언어|TypeScript, Go, Python (프로토콜 사용 시)|Java, C#, C++|

## 🧩 구조적 서브 타이핑에서 말하는 속성과 기능구조
### 🔷 구조적 타이핑에서의 “구조”란?
- 객체가 어떤 속성(attributes)과 메서드(methods)를 가지고 있는지, 그리고 그 메서드들의 시그니처가 어떻게 생겼는지를 말함.
- 즉, 클래스 이름이 무엇인지, 어떤 클래스를 상속했는지는 중요하지 않음.
- 형태(shape)와 기능(signature) 만 중요함.

### 🔷 구조적 서브 타이핑에서의 객체의 형태 (속성 + 기능구조)
|구분|설명|예시|
|---|---|---|
|속성 (Attributes)|인스턴스 변수, 프로퍼티 등 — 즉, 객체가 “가지고 있는 데이터”|self.name, self.age, self.id|
|기능 구조 (Methods)|객체가 “할 수 있는 행동” — 즉, 메서드 이름 + 매개변수 + 반환타입 시그니처|def fly(self) -> None, def save(self) -> bool|


---

코드 예시 (타입스크립트)

```
interface Pet {
    name: string;
}

interface Cat {
    name: string;
    age: number;
}

let pet1: Pet;
let cat1: Cat = { name: "jerry", age: 2 };

pet1 = cat1; // ok
// cat1 = pet1; // 에러 -> age가 pet1에 없음

function greet(pet: Pet) {
    console.log("hello, " + pet.name);
}

// 매개변수 타입이 달라도 인수가 될 수 있음
greet(cat1); // "hello, jerry"
```

⬇️ 상속받지 않았음에도 구조가 동일하여 타입 호환이 가능.
```
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`);
}

const developer = new Developer("zig", 20, 7);

// Person 인스턴스 대신 Develop 인스턴스를 사용 가능
greet(developer); // Hello, I'm zig
```

## 🦆 덕 타이핑 (== 구조적 타이핑)
### 개념
- 타입 결정 기준 : "어떤 구조와 기능"을 가지고 "어떻게 사용"되는가
- 오리처럼 울고(속성) + 걷는다(기능) -> 원래 오리가 아니라고 하더라도 오리 type과 호환되게끔 코드를 작성.
- 구조적 타이핑 정적 타이핑에서, 덕 타이핑은 동적 타이핑에서 주로 사용됨.

## 🦆 덕 타이핑 vs 🧩 구조적 타이핑
- 핵심 차이:  검사 시점(언제 확인하느냐)&검사 주체(누가 확인하느냐)

|구분|구조적 타이핑 (Structural Typing)|덕 타이핑 (Duck Typing)|
|---|---|---|
|정의|“형태(구조)”가 같으면 같은 타입으로 본다. 즉, 이름보다 구조를 본다.|“실제 실행 시점에 그 메서드를 가지고 있으면 된다.”|
|검사 시점|정적 시점 (Static) – 실행 전에 타입 체커(mypy 등)가 검사|동적 시점 (Runtime) – 실행 중에 실제 객체가 메서드를 가지고 있는지 확인|
|검사 주체|mypy, pyright, pyre 같은 정적 타입 체커|파이썬 런타임(interpreter) 자체|
|대표 도구|Protocol (from typing)|try/except 기반 EAFP 스타일|
|에러 탐지 시점|실행 전 발견|실행 중에 AttributeError 발생|
|철학|“계약 기반” (형태를 사전에 명시)|“행동 기반” (실제 동작이 되면 OK)|

## 🔶 정리
quack()과 walk() 둘 다 있어야 완전한 오리로 취급받는다.
하나라도 없으면 **“덕 타이핑 실패”**로 보고,
런타임에 예외를 던지는 게 파이썬식 접근(EAFP)이다.

### EAFP(Easier to Ask Forgiveness than Permission)
- “허락을 미리 구하지 말고, 나중에 문제 생기면 사과하라.”
- 사전에 검사(if hasattr(…))하지 않고, 그냥 시도한 다음 안되면 예외 처리.
