# 아이템_06_불필요한 객체 생성을 피하라


# **🟦 1. 서론 (Introduction)**

**발표 목적**

- **“객체 생성 자체가 문제인 게 아니라, 불필요하게 중복 생성하는 습관이 문제다.”**

**배경 / 문제 인식**

- 객체 지향 언어인 Java에서는 객체 생성을 통해 모든 것이 이루어진다.
하지만 모든 객체 생성이 의미 있는 것은 아니다. 
같은 기능을 수행하면서도 재사용 가능한 객체를 매번 새로 만드는 코드는 성능 저하와 불필요한 메모리 사용을 초래한다.

**목표 / 기대 효과**

- 불필요한 객체 생성을 하지 않고 재사용함으로서 프로그램의 성능과 코드 가독성을 높일 수 있다.

# **🟨 2. 본론 (Main Content)**

---

## **1️⃣ 핵심 개념 정리 (장점 & 단점)**

### **🔹 1️⃣ Java의 “객체 생성 = 비용이 따른다”**

- new 연산자는 단순한 메모리 할당이 아니라,
    - 클래스 로딩, 초기화, 생성자 호출, GC 대상 관리까지 포함된 **비용 있는 작업**이다.
- 가벼운 객체라면 문제 없지만,
    - 내부적으로 **복잡한 구조를 가진 객체 (예: Pattern, Connection, Thread 등)** 을 반복적으로 생성하면 큰 오버헤드가 발생한다.

### **new 연산자 vs String 불변객체**

- 불변 클래스에서 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 막을 수 있다.
    - 생성자는 호출할 때마다 새로운 객체를 생성.
    - 팩터리 메서드는 불변 객체 뿐만 아니라 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용 가능.
    - **가 반복적으로 필요한 경우 캐싱해서 재사용할 것.**

---

## **2️⃣ “보이지 않는 낭비”가 발생하는 대표 사례**

## 사례 1. **정규표현식의 Pattern 객체**

- 문자열이 로마 숫자 형태인지 검사하는 정규표현식

```jsx
static boolean isRomanNumeral(String s){
  String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
  return s.matches(regex);
}
```

### **⚠️ 발생 문제**

- 성능 저하 : 정규식을 매번 새로 해석하고 컴파일 함.
- 불필요한 객체 생성 : Pattern과 Matcher 인스턴스를 계속 새로 만듦.
    - 성능이 중요한 상황에서 반복해서 사용하기란 적합하지 않음.
    - 메서드가 내부에서 만드는 정규표현식 Pattern 인스턴스는 한번 쓰고 버려져 GC 대상이 됨.
    - Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신(Finite State Machine)을 만들기 때문에 인스턴스 생성 비용이 높음.

---

### **🔹 s.matches(regex) 내부 동작**

```jsx
String regex = "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
Pattern p = Pattern.compile(regex);
Matcher m = p.matcher(s);
return m.matches();
```

- isRomanNumeral 호출 시마다 Pattern과 Matcher 객체가 새로 생성됨.

**Pattern 객체**

- java.util.regex.Pattern 클래스의 인스턴스.
- 문자열 형태의 정규식을 JVM이 이해할 수 있는 형태로 바꿔서 저장해둔 객체.

**Matcher 객체**

- 문자열이 정규표현식 패턴과 일치하는지를 실제로 검사하는 실행기(executor).

---

### **🔷 인스턴스 생성 비용이 높음**

- Pattern.compile(regex) :
    - 정규식을 유한 상태 머신(FSM)으로 바꾸는 것은 단순 문자열 파싱이 아님.
    - 복잡한 분기/루프 구조(NFA)를 한 번 만들어 놓음 → 비용이 큼(파싱 + 상태구조 생성).

```jsx
패턴해석 -> 문자열 전이 경로 계산 -> 루프(*, +), 조건(|), 그룹(()) 처리
```

- 정규식을 Pattern.compile()로 새로 컴파일하여 Pattern 객체 생성 (NFA 구조).
    - Pattern.compile(regex)시 생성되는 Pattern 객체 생성 예시 (NFA 구조)
        
        ```jsx
        [START] --(?=.)--> [S0]
        [S0] --M--> [S0]        (M*)  (S0은 M 루프 상태)
        [S0] --ε--> [H_START]   (hundreds 분기 시작)
        
        # hundreds 분기 A (CM/CD)
        [H_START] --'C'--> [H_A1] --'M' or 'D'--> [H_A_END]
        
        # hundreds 분기 B (D? C{0,3})
        [H_START] --ε--> [H_B0]
        [H_B0] --'D'--> [H_B1]   (optional D)
        [H_B0] --ε--> [H_B1]
        [H_B1] --'C'--> [H_B2] --'C'--> [H_B3] --'C'--> [H_B4]
        (각 H_B* 상태는 C{0,3} 반복)
        
        # after hundreds
        [H_A_END] --ε--> [T_START]
        [H_B4]     --ε--> [T_START]
        
        # tens 분기 (유사)
        [T_START] --'X'--> ... (X[CL] branch)
        or
        [T_START] --ε--> ... (L? X{0,3} branch)
        
        # ones 분기 (유사)
        ... --> [ONES_START]
        [ONES_START] --'I' ... or --ε--> ... (V? I{0,3})
        
        # 끝
        [...] --> [ACCEPT] --(must be at end due to $)-->
        ```
        
- Matcher 객체를 생성 후 m.matches() 수행 → 매칭 결과 반환.
- 결과 반환 후 Pattern, Matcher 모두 GC 대상.

---

## **3️⃣ 문제점 & 해결 방안**

### **성능 개선 방법**

- 필요한 정규식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성하여 캐싱.
- 나중에 isRomanNumeral 메서드가 호출될 때마다 해당 인스턴스를 재사용.

```jsx
public class RomanNumerals {
  private static final Pattern ROMAN = Pattern.compile(
    "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

  static boolean isRomanNumeral(String s) {
    return ROMAN.matcher(s).matches();
  }
}
```

### **개선 효과**

- 성능 개선 : 6.5배 정도 빨라짐 (길이가 8인 문자열 기준).
- 코드의 의미가 잘 드러남 : Pattern 인스턴스를 static final 필드로 끄집어내 의미를 명확히 함.

---

### **🔶 정적 유틸리티 메서드 vs 정적 팩터리 메서드**

| **구분** | **정적 유틸리티 메서드 (Static Utility)** | **정적 팩토리 메서드 (Static Factory)** |
| --- | --- | --- |
| 목적 | 특정 기능 수행, 계산, 검사 등 | 객체 생성 및 반환 |
| 반환 값 | 주로 primitive, boolean, void 등 | 항상 객체 인스턴스 |
| 객체 생성 | 기존 객체를 재사용할 수 있음, 새 객체 생성 필수 아님 | 새로운 객체 생성하거나, 캐시된 인스턴스 반환 가능 |
| 예시 | Math.max(a,b), Collections.sort(list), RomanNumerals.isRomanNumeral(s) | Integer.valueOf(42), LocalDate.of(2025,10,24) |

## **사례 1. 어댑터(Adapter) 객체**

- 어댑터는 뒷단 객체에 요청을 위임하는 뷰(View) 역할을 함.
- 어댑터 자체는 불변처럼 보이지만, 내부적으로 상태나 캐시를 가질 수 있음.
- 뒷단 객체가 변경되면 어댑터를 재사용할 때 “**상태 공유 문제”**가 생길 수 있음.
- ✅ 결론: 겉보기 불변이라도 재사용 시 주의가 필요.

## **사례 2. Map 인터페이스의 keySet 메서드**

```jsx
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

Set<String> keys1 = map.keySet();
Set<String> keys2 = map.keySet();
```

| **개념** | **설명** |
| --- | --- |
| keySet() | Map의 키 전체를 보여주는 “뷰(View)” 객체 반환 |
| 뷰(View) | 원본 Map을 감싸서 간접적으로 접근하게 하는 객체 |
| 공유 구조 | map을 수정하면 keySet() 결과도 즉시 반영됨 |
| 특징 | 복사본이 아닌, 원본과 실시간 연결된 객체 |
- keySet()은 새로운 Set 복사본을 만들지 않음.
- 내부적으로 같은 Set 뷰를 반환하거나 동일한 기능의 뷰를 만들어도 결과 동일.
- 불필요한 객체 생성을 방지할 수 있음.

---

## **사례 3. 오토박싱 (auto boxing)**

```jsx
private static long sum() {
    Long sum = 0L; // ❌ Long (박싱 타입)
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

### ⚠️ **문제점**

- sum이 박싱 타입(Long)이므로 sum += i; 연산 시마다 새로운 Long 객체가 생성됨.
- 반복문이 21억 번 도는 동안 21억 개의 Long 객체가 만들어짐.

✅ **개선 코드**

```jsx
private static long sum() {
    long sum = 0L; // ✅ 기본 타입 사용
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```

| **코드** | **실행 시간(대략)** |
| --- | --- |
| Long sum = 0L | 6.3초 |
| long sum = 0L | 0.59초 |

---

### **객체 생성은 비싸니 항상 피해야 한다? → ❌**

- 현대 JVM에서는 단순한 객체 생성/회수는 부담이 크지 않음.
- 명확성, 간결성, 기능 향상을 위해 객체를 추가 생성하는 것은 오히려 바람직함.

---

### **객체 풀(pool) 사용에 대한 주의점**

- DB 연결처럼 생성 비용이 큰 객체는 재사용 추천.
- 하지만 일반 객체는 직접 풀을 만들지 말 것.
- 자체 풀은 코드 복잡도 증가, 메모리 낭비, 성능 저하를 유발.
- JVM의 GC가 경량 객체 처리에 훨씬 효율적임.

---

### **🔶 아이템 6 vs 아이템 50 (방어적 복사)**

| **구분** | **아이템 6** | **아이템 50** |
| --- | --- | --- |
| 내용 | 기존 객체를 재사용해야 한다면 새 객체를 만들지 말라 | 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라 |
| 피해 규모 | 성능 저하 정도 | 🚨 버그 및 보안 구멍 위험 |
| 요약 | 불필요한 객체 생성을 피하라 | 방어적 복사를 게을리하지 말라 |

# **🟩 3. 요약 (Summary / Conclusion)**

**핵심 포인트 요약**

- 객체 생성은 비용이 클 경우, **재사용 가능한 객체는 재사용**하라. (항상 객체 생성 비용이 비싼 것은 아님)
- 정규식 Pattern, 불변 객체, 뷰(View) 객체 등은 캐싱하여 재사용하면 성능 향상.
- 오토박싱과 같은 **눈에 안 보이는 객체 생성**에 주의.
- 단, **명확성과 안정성을 해치지 않는 선**에서만 최적화할 것.

---

**느낀 점 / 인사이트**

- 불변과 재사용은 같은 개념이 아니다.
- 작은 습관 하나(ex. 기본 타입 사용, 정적 캐싱)로도 큰 성능 차이를 만든다.
- 무조건 객체 생성을 피하는 것이 아니라, **언제 재사용이 의미 있는지 판단하는 능력**이 중요하다.

---

**다음 단계 제안**

- 다음 발표에서는 **아이템 50(방어적 복사)** 와의 비교를 더 깊게 다루고,
    
    실제 코드 리팩토링 사례를 통해 “언제 새 객체를 만들어야 하는가”를 탐구할 예정.
    

---

# 🔶 질문 및 답변 (Q&A)

|  질문내용/ 질문자 | 김대화 | 이샤론 | 김석환 |
| --- | --- | --- | --- |
| 질문 | 정규식이 많아지면 static 필드가 많아지지 않을까요? 한 클래스 안에서 검사할 정규식이 10개가 넘는다면, static final pattern 필드도 10개 이상 선언해야 할까요?  | “Effective Java에서 ‘생성 비용이 비싼 객체는 재사용하라’고 하지만, 실제로 ‘생성 비용이 비싸다’는 기준을 명확히 정하기는 어렵다고 합니다. 그렇다면 객체 생성 비용이 비싸다고 판단할 수 있는 기준이나 상황은 무엇일까요? | Pattern 객체를 static final로 선언하는 이유가 외부에 객체 생성을 막고 중복생성을 막는 것이 이유인가요? 이것은 성능 개선과 코드 명확성 중 어느 관점에 의미가 있는 것일까요? |
| 답변 | 맞습니다. 👍 정규식이 많아지면 클래스 안에 static 필드가 너무 많아져서 코드가 지저분해지고 유지보수가 어려워질 수 있습니다. 그래서 Map을 활용한 동적 캐싱이나 Enum과 Pattern을 결합한 방식처럼, Pattern 객체를 재사용하면서도 깔끔하게 관리할 수 있는 방법들이 있습니다. 즉, 중요한 건 필드 개수가 아니라, Pattern 객체를 한 번만 생성하고 재사용함으로써 컴파일 비용을 절감하는 효과에 있습니다.| 객체 생성 비용이 “비싸다”는 것은 new 연산 자체가 아니라,그 객체를 만들기 위해 **CPU 연산**, **I/O 접근**, **자원 초기화** 등이 포함되어생성 과정이 복잡하거나 빈번히 호출될 때 시스템 부하로 이어질 정도의 경우를 말합니다. 따라서 단순한 값 객체보다는 **정규식, 데이터베이스 연결, 네트워크, 파일 접근 객체**처럼내부적으로 외부 자원이나 복잡한 초기화를 수행하는 경우가 재사용의 주요 대상이 됩니다. | Pattern 객체를 final과 static으로 선언한 이유는 불변으로 만들어 “재사용”을 위한 것입니다. == 외부 객체 생성을 “막는 것”이 아니라, **“필요 이상으로 새로 만들지 않기 위해” 클래스 내부적으로 재사용**하는 것입니다. 즉, 불변성을 보장하고 클래스 단위로 재사용하기 위한 설계 의도라고 볼 수 있습니다. 개선되기 전 코드를 보시면 s.matches(regex); 부분은 비효율적이라고 말씀드렸습니다. isRomanNumeral()을 호출할 때마다 Pattern 객체와 Matcher 객체를 생성해서 사용하기 때문이죠! 저렇게 Pattern 타입으로 불변(final) + 공용(static) 변수를 만들어서 Pattern.compile(regex)로 한번 정규식 구조 틀(유한상태머신(FSM))을 만들어두면 정규식을 매번 새로 해석할 필요가 없습니다. 결과적으로 성능 + 코드 가독성 즉, s.matches(regex); 내부에 감추어져있던 Pattern 객체를 꺼내서 정규식 패턴을 만들었다는 것을 가시화 하여 확인할 수 있기 때문에 성능 + 가독성 둘 다 의미가 있다고 볼 수 있습니다. 추가적으로 Pattern은 불변 객체이기 때문에,여러 스레드가 동시에 접근해도 안전하게 공유할 수 있습니다.따라서 이 방식은 **성능과 코드 명확성 두 측면에서 모두 이점이 있는 설계**라고 볼 수 있습니다. |

### ✚ 추가자료
- Pattern이 불변객체라는 증거.
자바 Doc 공식문서 참고

```jsx
//이 클래스(Pattern)의 인스턴스는 "불변"
Instances of this class are immutable and are safe for use by multiple concurrent threads.

//final -> 불변임
public final class Pattern
extends Object
implements Serializable
```

```jsx
//Pattern은 불변 객체라는 것을 알 수 있음.
public final class Pattern implements java.io.Serializable {
    private final String pattern;
    private final int flags;
    transient volatile boolean compiled;
    transient PatternNode root;
    ...
}
```
