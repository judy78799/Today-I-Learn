## 다중상속
- 부모: 기반 클래스
- 자식: 파생 클래스
- 다중상속의 우선순위 정리 필요
```
class Car(object):  
    maxSpeed = 300  
    maxPeople = 5  
    def move(self, x):  
        print(x, '의 스피드로 움직이고 있습니다.')  
    def stop(self):  
        print('멈췄습니다.')

class HybridCar(Car):  
    battery = 1000  
    batteryKM = 300

class ElectricCar(Car):  
    battery = 2000  
    batteryKM = 600  
    def move(self, x):  
        print(self.batteryKM, '만큼 달릴 수 있습니다.')  
        print(x, '스피드로 달리고 있습니다.')

# 우선순위 : HybridElectricCar > HybridCar > ElectricCar
class HybridElectricCar(HybridCar, ElectricCar):  
    pass

k5 = HybridElectricCar()  
print(K5.battery) # 1000
```

## 다이아몬드 상속 문제
<img width="448" height="674" alt="image" src="https://github.com/user-attachments/assets/cdcd84a7-dbaa-4752-8345-ee8ccabcb6b8" />
<br>
- 클래스 A를 상속: B, C.
- 클래스 B와 C 상속: D.
- A, B, C 모두 greeting() 가지고 있음.

### ambiguous 상태 지양
- D는 B와 C중에 어떤 메서드를 호출해야 하는 지 애매모호한 상태.
- 프로그램이 어떨 때는 A의 메서드를 호출하고, 또 어떨 때는 B 또는 C의 메서드를 호출한다면 큰 문제가 생길 수 있기 때문.

## 방법 1) MRO(Method Resolution Order, MRO), 메서드 탐색 순서
- 기본적으로 python은 다중 상속을 한다면 class D(B, C):의 클래스 목록 중 왼쪽에서 오른쪽 순서로 메서드를 찾는다.
- 상속 관계가 복잡하게 얽혀 있다면 MRO를 살펴보자.

```
D.mro() 
```

## 방법 2) 구성(Composition) / 위임(Delegation) 사용

```
class A:
    def do(self): print("A")
class B:
    def do(self): print("B")
class C(A, B):
    pass

C().do()  # A가 출력: 사용자가 기대한 동작이 아닐 수 있음
```

```
class A:
    def do(self): print("A")
class B:
    def do(self): print("B")

class C:
    def __init__(self, a: A, b: B):
        self._a = a   # 구성: C는 A를 포함
        self._b = b   # 구성: C는 B를 포함
    def do_a(self): self._a.do()    # 위임: C가 직접 하는 게 아니라 A한테 시킴
    def do_b(self): self._b.do()    # 위임: C가 직접 하는 게 아니라 B한테 시킴
```
  

## 다중상속시 유의할 점 
1. 인터페이스 상속과 구현 상속을 구분 (인터페이스는 is-a -서브타입 확장) 
    -> 인터페이스 상속 = is-a 보장 -> “나는 이 타입의 한 종류다”라는 관계를 보장 -> 서브 타입 확장.
    -> 구현 상속 = is-a 보장 안 됨 -> if, 단순히 "메서드 구현 재사용"이 목적 -> 구성(Composition) 또는 **믹스인(Mixin)** 사용.
2. ABC(추상클래스)를 활용해서 인터페이스를 명확히 한다. 
3. 코드 재사용을 위해 믹스인을 사용해라.
4. 두 개 이상의 구상 클래스에서 상속받지 않는다.


### Mixin
- 코드 재사용시, Mixin을 사용하라.
- 믹스인은 작은 단일 책임(예: 로깅, 직렬화, 타임스탬프 추가)만 제공하는 클래스.
- 클래스 이름 끝에 Mixin을 붙이고, 상태를 많이 갖지 않도록 설계함.
- 믹스인은 다른 클래스들과 조합되어 기능을 더하는 용도지, 독립적인 완전한 부모 클래스가 아님. 상태ful(많은 속성) 믹스인은 충돌 유발.
- 믹스인에서 __init__을 쓰면 super()를 통해 협조적으로 체인을 이어줘야 함(아니면 깔끔하지 못함).
- 믹스인들끼리 메서드 이름이 겹치면 예측하기 어려운 동작이 나온다(→ MRO 영향).


코드 예시
```
class TimestampMixin:
    def created_at(self):
        import datetime
        return datetime.datetime.now()

class JsonSerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class User(TimestampMixin, JsonSerializableMixin):
    def __init__(self, name):
        self.name = name

u = User("alice")
print(u.created_at(), u.to_json())
```

### 부수 팁 — 실무에서의 권장 패턴
	•	인터페이스(추상화) 먼저, 구현은 나중: API(메서드 시그니처)를 먼저 정의해놓으면 테스트와 모킹이 쉬움.
	•	믹스인은 명확한 목적(orthogonal behavior)을 가질 것: 예) LoggingMixin, RetryMixin, JsonMixin.
	•	super()를 일관되게 사용하라: 다중 상속 체인에서 안전하게 생성자/메서드 체인을 이어주려면 모든 클래스에서 super()를 호출해야 함.
	•	상태가 복잡하면 composition 선택: 여러 concrete 기능을 합쳐야 한다면 합성으로 명시적 위임을 권장.
	•	타입 검사 도구(mypy) 활용: Protocol/ABC로 계약을 만들면 타입 검사기로 실수를 잡을 수 있음.
